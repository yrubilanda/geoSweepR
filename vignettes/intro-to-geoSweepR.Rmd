---
title: "intro-to-geoSweepR"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{intro-to-geoSweepR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r}
devtools::load_all() # to knit i have to run this each time? i hope not messing up
library(geoSweepR)
```

## Introduction

This vignette demonstrates how to use the `geoSweepR` package to visualize point-based geospatial data using smooth heatmaps. The package includes functions to generate 2D kernel density plots that highlight areas of high spatial concentration, with optional filtering by data type or category. Users can also overlay a basemap from external tile providers (e.g., CartoDB) to enhance spatial context.

While this example uses crime incident data as a sample dataset, the tools provided in `geoSweepR` are suitable for a wide range of applications, including environmental sightings, service usage patterns, infrastructure reporting, and more.

```{r}
# Load sample data (replace with your actual data if needed)
library(readr)
data_path <- system.file("extdata", "dc_sample.csv", package = "geoSweepR") #YOU NEED TO USE THE DUMMY DATA IN THE EXTDATA FOLDER! THIS IS CRISTINAS CLEAN DATA
data <- read_csv(data_path, col_names = TRUE)
head(data)
```

## Function 1: make_heatmap by yrubilanda

The `make_heatmap()` function is the core tool in this package — it creates a smooth 2D heatmap using your point data (latitude and longitude). You can keep it simple and plot everything, or customize it with optional parameters to filter by type and add a basemap for context.

This function is flexible depending on what you want to show: - You can run it with just your coordinates and it’ll plot all your points. - You can filter the data by category using `col_data` and `filter_by`. - You can also include a basemap from map tiles (like CartoDB or OpenStreetMap) if you want something in the background.

Here are some ways to use it:

``` r
# Heatmap of all points (no filtering, no basemap)
make_heatmap(my_data, lat_col = "latitude", lon_col = "longitude")

# Heatmap filtered by a specific type (in this case, only "Theft" from the offense column)
make_heatmap(my_data, lat_col = "latitude", lon_col = "longitude",
             col_data = "offense", filter_by = "Theft")

# Heatmap with a basemap layer in the background
make_heatmap(my_data, lat_col = "latitude", lon_col = "longitude",
             basemap = my_basemap)
```

```{r}
# This is the simplest version of the function — just make a heatmap of ALL your points
make_heatmap(
  data = data,           # your full dataset (must have lat/lon columns)
  lat_col = "latitude",  # column that holds the latitude values
  lon_col = "longitude", # column that holds the longitude values
  col_data = NULL,       # you also can just leave this blank so just do not write in
  filter_by = NULL,
  basemap = NULL
)

# NOTE:
# This does NOT filter by any category — it includes every row in your dataset.
# There's also no basemap in the background — just a clean heatmap showing areas with more data points.
# This is a great starting point if you just want to see the overall spatial density of your data.

```

```{r}
# Call the heatmap function using just your point data — no basemap but you can filter by type within your column
make_heatmap(
  data = data,          # your dataset (must include lat/lon columns)
  lat_col = "latitude", # the column in your data that has latitude values
  lon_col = "longitude",# the column that has longitude values
  col_data = "offense", # this is the column we're filtering on (like type or category of data)
  filter_by = "Robbery" # only include rows where offense == "Robbery"
)
```

```{r}
# Load libraries needed for getting a basemap and working with spatial data
library(maptiles)  # for downloading map tile layers like CartoDB
library(sf)        # for handling spatial objects like bounding boxes

# --- NOTE TO USERS ---
# The code below creates a basemap specifically for the DC crime data we're using in this example.
# The bbox values (xmin, xmax, ymin, ymax) define the area of interest in Washington, D.C.
# 
# Our `make_heatmap()` function **does not generate this basemap** — you’ll need to set this up yourself
# based on the bounding box that makes sense for your own dataset (e.g., different city or region).
# This step is fully up to the user — the function just adds it if you provide one.

# Create a bounding box around the area you want to show on the map (in this case, part of D.C.)
bbox <- sf::st_as_sfc(
  sf::st_bbox(c(
    xmin = -77.05,  # western boundary of the area (longitude)
    xmax = -76.95,  # eastern boundary (longitude)
    ymin = 38.85,   # southern boundary (latitude)
    ymax = 38.95    # northern boundary (latitude)
  ), crs = sf::st_crs(4326))  # Set the coordinate reference system (WGS84)
)

# Download the basemap tiles for that bounding box using the CartoDB Positron provider
# You could change the provider to something else like OpenStreetMap or Stamen if you want a different style
raster_map <- get_tiles(bbox, provider = "CartoDB.Positron")

# Now use the heatmap function!
# This draws a density map of only "Robbery" incidents from the "offense" column,
# and overlays it on the CartoDB basemap we just downloaded
make_heatmap(
  data = data,               # your dataset with coordinates and optional filter column
  lat_col = "latitude",      # name of the latitude column
  lon_col = "longitude",     # name of the longitude column
  col_data = "offense",      # column to filter by (can be type, category, etc.)
  filter_by = "Robbery",     # specific value to filter for (e.g., "Robbery")
  basemap = raster_map       # the basemap image to use as a background (optional)
)

```

## Function 2: density_kriging by wompusjr

The `density_kriging()` function is a secondary tool for the analysis of spatial data — it creates a basic gridded density plot using your point data (longitude and latitude). This plot displays the predicted density of observations at unobserved tiles to extrapolate your results from the original heatmap to a larger area. The function comes with set grid size and variogram model type, but these are customizable - as is the CRS, which will be converted to metric from a provided CRS.

This function is designed to be used on categorical data by calculating the density of observations. By calculating density, you can use kriging methods that you would otherwise be incapable of doing by transforming the data into a continous variable with explanatory power.

The function also has some flexibility - You can run it with just your coordinates and it’ll produce a prediction from all of your points - You can filter the data by category using `col_data` and `filter_by`.

Here are some ways to use it:

``` r
# Plot density in standard grids and variogram types
density_kriging(my_data, lon_col = "longitude", lat_col = "latitude", crs = 4326)

# Plot density at a different grid size or variagram style - for example 250 m^2 grid and a gaussian variogram
density_kriging(my_data, lon_col = "longitude", lat_col = "latitude", crs = 4236, grid_size = 250, variogram_model = "Gau")

# Plot density with a just one kind of data -for example, only "Theft"
density_kriging(my_data, lon_col = "longitude", lat_col = "latitude", crs = 4326, col_data = "offense", filter_by = "Theft")
```

```{r}
# Basic version of the function, running the entire code at standard levels
density_kriging(
  data = data,            # your full dataset (must have lat/lon columns)
  lon_col = "longitude", # column that holds the latitude values
  lat_col = "latitude",   # column that holds the longitude values
  crs = 4326,             #CRS for the data region - Washington DC 
  col_data = NULL,        #you can also leave this and the following sections blank to produce the base result
  filter_by = NULL, 
  grid_size = 500, 
  variogram_model = "Sph")

# NOTE:
# This does NOT filter by any category — it uses a count derived from your entire dataset.

# This is a good way to visualize how general trends in your data can be extrapolated beyond the recorded observation.

```

```{r}
# Adjusted code displaying how using smaller grids could affect the data
density_kriging(
  data = data,            # your full dataset (must have lat/lon columns)
  lon_col = "longitude", # column that holds the latitude values
  lat_col = "latitude",   # column that holds the longitude values
  crs = 4326,             #CRS for the data region - Washington DC 
  grid_size = 250)

# NOTE:
# This still does NOT filter by any category — it uses a count derived from your entire dataset but uses smaller grid sizes to get more granular with the visualization

# This can be useful for smaller datasets and for visualizing boundaries

```

```{r}
# You can filter by specific values in particular categorical variables
density_kriging(
  data = data,            # your full dataset (must have lat/lon columns)
  lon_col = "longitude", # column that holds the latitude values
  lat_col = "latitude",   # column that holds the longitude values
  crs = 4326,             #CRS for the data region - Washington DC 
  col_data = "offense",     
  filter_by = "Robbery")

# NOTE:
# This is a good way to visualize a specific categorical value or variable
```
