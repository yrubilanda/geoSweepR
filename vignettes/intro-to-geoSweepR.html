<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>intro-to-geoSweepR</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">intro-to-geoSweepR</h1>



<p>TAKES ABOUT 5 MINUTES TO RENDER SO FAR 4/30 11:00AM, 2 FUNCTIONS</p>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>This vignette demonstrates how to use the <code>geoSweepR</code>
package to visualize point-based geospatial data using smooth heatmaps.
The package includes functions to generate 2D kernel density plots that
highlight areas of high spatial concentration, with optional filtering
by data type or category. Users can also overlay a basemap from external
tile providers (e.g., CartoDB) to enhance spatial context.</p>
<p>At minimum, all functions in this package require that users input a
<code>data</code> parameter, which should be a data frame containing
point-based spatial data with clearly defined latitude and longitude
columns. The names of these columns must be specified within the
function using the parameters <code>lat_col</code> and
<code>long_col</code>, which must be strings of data within the
<code>data</code> parameter.</p>
<p>Optionally, users can also input filters to visualize a singular
category or factor variable. This option is achieved by specifying the
parameter <code>col_data</code>, which refers to the column used to
filter the data set, and the parameter <code>filter_by</code>, which
refers to a particular value within that column. Users should be aware
that the filter option will not work, unless both <code>col_data</code>
and <code>filter_by</code> are specified within the function. Users also
have the option to overlay their heatmap or density plot on a spatial
object, such as an <code>sf</code> or <code>raster</code> object by
calling the parameter <code>basemap</code>.</p>
<p>Functions in this package also support coordinate reference system
(CRS) customization through the <code>input_crs</code> parameter. Users
can use this parameter by specifying an EPSG code or PROJ string. By
default, all functions assume that <code>input_crs</code> is set to
EPSG:4326 (WGS 84).</p>
<p>While this example uses crime incident data as a sample dataset, the
tools provided in <code>geoSweepR</code> are suitable for a wide range
of applications, including environmental sightings, service usage
patterns, infrastructure reporting, and more. This example also uses a
sample basemap, saved as a <code>.tif</code> file. Users can create or
download their own basemaps to fit individual data sets.</p>
<p>The sample data set used here was obtained from the publicly
available website DATA.GOV. You can find the data by clicking on this <a href="https://catalog.data.gov/dataset/crime-incidents-in-2024">link</a>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># Load sample data (replace with your actual data if needed)</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>data_path <span class="ot">&lt;-</span> <span class="fu">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="st">&quot;dc_sample.csv&quot;</span>, <span class="at">package =</span> <span class="st">&quot;geoSweepR&quot;</span>) <span class="co">#YOU NEED TO USE THE DUMMY DATA IN THE EXTDATA FOLDER! THIS IS CRISTINAS CLEAN DATA</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>my_data <span class="ot">&lt;-</span> readr<span class="sc">::</span><span class="fu">read_csv</span>(data_path, <span class="at">col_names =</span> <span class="cn">TRUE</span>)</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="co">#&gt; Rows: 27614 Columns: 9</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="co">#&gt; ── Column specification ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="co">#&gt; Delimiter: &quot;,&quot;</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="co">#&gt; chr  (6): month, week_day, shift, offense, block, neighborhood_cluster</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="co">#&gt; dbl  (2): latitude, longitude</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="co">#&gt; dttm (1): report_dat</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="co">#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.</span></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="co">#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</span></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a><span class="fu">head</span>(my_data)</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a><span class="co">#&gt; # A tibble: 6 × 9</span></span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a><span class="co">#&gt;   report_dat          month   week_day shift    offense  block                                    neighborhood_cluster latitude longitude</span></span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a><span class="co">#&gt;   &lt;dttm&gt;              &lt;chr&gt;   &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;                                    &lt;chr&gt;                   &lt;dbl&gt;     &lt;dbl&gt;</span></span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a><span class="co">#&gt; 1 2024-01-01 05:00:00 January Monday   Midnight Homicide 4300 - 4399 BLOCK OF MILITARY ROAD NW    Cluster 11               39.0     -77.1</span></span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a><span class="co">#&gt; 2 2024-01-01 05:16:54 January Monday   Midnight Robbery  1820 - 1899 BLOCK OF 14TH STREET NW      Cluster 3                38.9     -77.0</span></span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a><span class="co">#&gt; 3 2024-01-01 05:27:45 January Monday   Midnight Theft    4000 - 4099 BLOCK OF MARLBORO PLACE NW   Cluster 18               38.9     -77.0</span></span>
<span id="cb1-20"><a href="#cb1-20" tabindex="-1"></a><span class="co">#&gt; 4 2024-01-01 05:57:47 January Monday   Midnight Theft    1200 - 1259 BLOCK OF QUEEN STREET NE     Cluster 23               38.9     -77.0</span></span>
<span id="cb1-21"><a href="#cb1-21" tabindex="-1"></a><span class="co">#&gt; 5 2024-01-01 07:10:56 January Monday   Midnight Theft    400 - 599 BLOCK OF MICHIGAN AVENUE NE    Cluster 20               38.9     -77.0</span></span>
<span id="cb1-22"><a href="#cb1-22" tabindex="-1"></a><span class="co">#&gt; 6 2024-01-01 08:38:37 January Monday   Midnight Theft    2470 - 2599 BLOCK OF BALDWIN CRESCENT NE Cluster 24               38.9     -77.0</span></span>
<span id="cb1-23"><a href="#cb1-23" tabindex="-1"></a>my_basemap <span class="ot">&lt;-</span> terra<span class="sc">::</span><span class="fu">rast</span>(<span class="fu">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="st">&quot;my_basemap.tif&quot;</span>, <span class="at">package =</span> <span class="st">&quot;geoSweepR&quot;</span>))</span></code></pre></div>
</div>
<div id="function-1-make_heatmap-by-yrubilanda" class="section level2">
<h2>Function 1: make_heatmap by yrubilanda</h2>
<p>The <code>make_heatmap()</code> function is the core tool in this
package — it creates a smooth 2D heatmap using your point data (latitude
and longitude). You can keep it simple and plot everything, or customize
it with optional parameters to filter by type and add a basemap for
context.</p>
<p>This function is flexible depending on what you want to show: - You
can run it with just your coordinates and it’ll plot all your points. -
You can filter the data by category using <code>col_data</code> and
<code>filter_by</code>. - You can also include a basemap from map tiles
(like CartoDB or OpenStreetMap) if you want something in the
background.</p>
<p>Here are some ways to use it:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Heatmap of all points (no filtering, no basemap)</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="fu">make_heatmap</span>(my_data, <span class="at">lat_col =</span> <span class="st">&quot;latitude&quot;</span>, <span class="at">lon_col =</span> <span class="st">&quot;longitude&quot;</span>)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="co"># Heatmap filtered by a specific type (in this case, only &quot;Theft&quot; from the offense column)</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="fu">make_heatmap</span>(my_data, <span class="at">lat_col =</span> <span class="st">&quot;latitude&quot;</span>, <span class="at">lon_col =</span> <span class="st">&quot;longitude&quot;</span>,</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>             <span class="at">col_data =</span> <span class="st">&quot;offense&quot;</span>, <span class="at">filter_by =</span> <span class="st">&quot;Theft&quot;</span>)</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a><span class="co"># Heatmap with a basemap layer in the background</span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a><span class="fu">make_heatmap</span>(my_data, <span class="at">lat_col =</span> <span class="st">&quot;latitude&quot;</span>, <span class="at">lon_col =</span> <span class="st">&quot;longitude&quot;</span>,</span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>             <span class="at">basemap =</span> my_basemap)</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co"># This is the simplest version of the function — just make a heatmap of ALL your points</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="fu">make_heatmap</span>(</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>  <span class="at">data =</span> my_data,           <span class="co"># your full dataset (must have lat/lon columns)</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>  <span class="at">lat_col =</span> <span class="st">&quot;latitude&quot;</span>,  <span class="co"># column that holds the latitude values</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>  <span class="at">lon_col =</span> <span class="st">&quot;longitude&quot;</span>, <span class="co"># column that holds the longitude values</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>  <span class="at">col_data =</span> <span class="cn">NULL</span>,       <span class="co"># you also can just leave this blank so just do not write in</span></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>  <span class="at">filter_by =</span> <span class="cn">NULL</span>,</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>  <span class="at">basemap =</span> <span class="cn">NULL</span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>)</span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a><span class="co"># </span><span class="al">NOTE</span><span class="co">:</span></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a><span class="co"># This does NOT filter by any category — it includes every row in your dataset.</span></span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a><span class="co"># There&#39;s also no basemap in the background — just a clean heatmap showing areas with more data points.</span></span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a><span class="co"># This is a great starting point if you just want to see the overall spatial density of your data.</span></span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Call the heatmap function using just your point data — no basemap but you can filter by type within your column</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="fu">make_heatmap</span>(</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>  <span class="at">data =</span> my_data,          <span class="co"># your dataset (must include lat/lon columns)</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>  <span class="at">lat_col =</span> <span class="st">&quot;latitude&quot;</span>, <span class="co"># the column in your data that has latitude values</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>  <span class="at">lon_col =</span> <span class="st">&quot;longitude&quot;</span>,<span class="co"># the column that has longitude values</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>  <span class="at">col_data =</span> <span class="st">&quot;offense&quot;</span>, <span class="co"># this is the column we&#39;re filtering on (like type or category of data)</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>  <span class="at">filter_by =</span> <span class="st">&quot;Robbery&quot;</span> <span class="co"># only include rows where offense == &quot;Robbery&quot;</span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a>)</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co"># Now use the heatmap function!</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="co"># This draws a density map of only &quot;Robbery&quot; incidents from the &quot;offense&quot; column,</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="co"># and overlays it on the sample basemap</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="fu">make_heatmap</span>(</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>  <span class="at">data =</span> my_data,            <span class="co"># your dataset with coordinates and optional filter column</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>  <span class="at">lat_col =</span> <span class="st">&quot;latitude&quot;</span>,      <span class="co"># name of the latitude column</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>  <span class="at">lon_col =</span> <span class="st">&quot;longitude&quot;</span>,     <span class="co"># name of the longitude column</span></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a>  <span class="at">col_data =</span> <span class="st">&quot;offense&quot;</span>,      <span class="co"># column to filter by (can be type, category, etc.)</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>  <span class="at">filter_by =</span> <span class="st">&quot;Robbery&quot;</span>,     <span class="co"># specific value to filter for (e.g., &quot;Robbery&quot;)</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>  <span class="at">basemap =</span> my_basemap       <span class="co"># the basemap image to use as a background (optional)</span></span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a>)</span></code></pre></div>
</div>
<div id="function-2-density_kriging-by-wompusjr" class="section level2">
<h2>Function 2: density_kriging by wompusjr</h2>
<p>The <code>density_kriging()</code> function is a secondary tool for
the analysis of spatial data — it creates a basic gridded density plot
using your point data (longitude and latitude). This plot displays the
predicted density of observations at unobserved tiles to extrapolate
your results from the original heatmap to a larger area. The function
comes with set grid size and variogram model type, but these are
customizable - as is the CRS, which will be converted to metric from a
provided CRS.</p>
<p>This function is designed to be used on categorical data by
calculating the density of observations. By calculating density, you can
use kriging methods that you would otherwise be incapable of doing by
transforming the data into a continous variable with explanatory
power.</p>
<p>The function also has some flexibility - You can run it with just
your coordinates and it’ll produce a prediction from all of your points
- You can filter the data by category using <code>col_data</code> and
<code>filter_by</code>.</p>
<p>Here are some ways to use it:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co"># Plot density in standard grids and variogram types</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="fu">density_kriging</span>(my_data, <span class="at">lon_col =</span> <span class="st">&quot;longitude&quot;</span>, <span class="at">lat_col =</span> <span class="st">&quot;latitude&quot;</span>, <span class="at">crs =</span> <span class="dv">4326</span>)</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co"># Plot density at a different grid size or variagram style - for example 250 m^2 grid and a gaussian variogram</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="fu">density_kriging</span>(my_data, <span class="at">lon_col =</span> <span class="st">&quot;longitude&quot;</span>, <span class="at">lat_col =</span> <span class="st">&quot;latitude&quot;</span>, <span class="at">crs =</span> <span class="dv">4236</span>, <span class="at">grid_size =</span> <span class="dv">250</span>, <span class="at">variogram_model =</span> <span class="st">&quot;Gau&quot;</span>)</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a><span class="co"># Plot density with a just one kind of data -for example, only &quot;Theft&quot;</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a><span class="fu">density_kriging</span>(my_data, <span class="at">lon_col =</span> <span class="st">&quot;longitude&quot;</span>, <span class="at">lat_col =</span> <span class="st">&quot;latitude&quot;</span>, <span class="at">crs =</span> <span class="dv">4326</span>, <span class="at">col_data =</span> <span class="st">&quot;offense&quot;</span>, <span class="at">filter_by =</span> <span class="st">&quot;Theft&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co"># Basic version of the function, running the entire code at standard levels</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="fu">density_kriging</span>(</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>  <span class="at">data =</span> my_data,            <span class="co"># your full dataset (must have lat/lon columns)</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>  <span class="at">lon_col =</span> <span class="st">&quot;longitude&quot;</span>, <span class="co"># column that holds the latitude values</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>  <span class="at">lat_col =</span> <span class="st">&quot;latitude&quot;</span>,   <span class="co"># column that holds the longitude values</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>  <span class="at">input_crs =</span> <span class="dv">4326</span>,             <span class="co">#CRS for the data region - Washington DC </span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>  <span class="at">col_data =</span> <span class="cn">NULL</span>,        <span class="co">#you can also leave this and the following sections blank to produce the base result</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a>  <span class="at">filter_by =</span> <span class="cn">NULL</span>, </span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a>  <span class="at">grid_size =</span> <span class="dv">500</span>, </span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a>  <span class="at">variogram_model =</span> <span class="st">&quot;Sph&quot;</span>)</span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a><span class="co"># </span><span class="al">NOTE</span><span class="co">:</span></span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a><span class="co"># This does NOT filter by any category — it uses a count derived from your entire dataset.</span></span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a><span class="co"># This is a good way to visualize how general trends in your data can be extrapolated beyond the recorded observation.</span></span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="co"># Adjusted code displaying how using smaller grids could affect the data</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="fu">density_kriging</span>(</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>  <span class="at">data =</span> my_data,            <span class="co"># your full dataset (must have lat/lon columns)</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>  <span class="at">lon_col =</span> <span class="st">&quot;longitude&quot;</span>, <span class="co"># column that holds the latitude values</span></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>  <span class="at">lat_col =</span> <span class="st">&quot;latitude&quot;</span>,   <span class="co"># column that holds the longitude values</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>  <span class="at">input_crs =</span> <span class="dv">4326</span>,             <span class="co">#CRS for the data region - Washington DC </span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>  <span class="at">grid_size =</span> <span class="dv">250</span>)</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a><span class="co"># </span><span class="al">NOTE</span><span class="co">:</span></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a><span class="co"># This still does NOT filter by any category — it uses a count derived from your entire dataset but uses smaller grid sizes to get more granular with the visualization</span></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a><span class="co"># This can be useful for smaller datasets and for visualizing boundaries</span></span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># You can filter by specific values in particular categorical variables</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="fu">density_kriging</span>(</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>  <span class="at">data =</span> my_data,            <span class="co"># your full dataset (must have lat/lon columns)</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>  <span class="at">lon_col =</span> <span class="st">&quot;longitude&quot;</span>, <span class="co"># column that holds the latitude values</span></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>  <span class="at">lat_col =</span> <span class="st">&quot;latitude&quot;</span>,   <span class="co"># column that holds the longitude values</span></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>  <span class="at">input_crs =</span> <span class="dv">4326</span>,             <span class="co">#CRS for the data region - Washington DC </span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>  <span class="at">col_data =</span> <span class="st">&quot;offense&quot;</span>,     </span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>  <span class="at">filter_by =</span> <span class="st">&quot;Robbery&quot;</span>)</span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a><span class="co"># </span><span class="al">NOTE</span><span class="co">:</span></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a><span class="co"># This is a good way to visualize a specific categorical value or variable</span></span></code></pre></div>
</div>
<div id="function-3-resample_heatmap-by-cgarcialeal5" class="section level2">
<h2>Function 3: resample_heatmap() by cgarcialeal5</h2>
<p>The <code>resample_heatmap()</code> function in the
<code>geoSweepR</code> package is designed as an alternative to the core
function <code>make_heatmap()</code>. It is designed to handle
situations where the geospatial data set is insufficient or limited. In
many real-life scenarios, data sets may not have enough spatial coverage
or resolution to generate meaningful visualizations. This function
addresses that issue by resampling the data set to increase its spatial
density and enable more informative heatmap visualizations. It
artificially creates new data points by resampling within the spatial
boundaries of the original data set. The output of this function
includes two objects: a <code>ggplot</code> object with a heatmap and a
<code>data frame</code> object with the resampled data. The new data
frame contains the same columns as the original data and two new columns
called <code>x</code> and <code>y</code>, which are created during the
execution of the function.</p>
<p>The parameter <code>n_samples</code> is unique to this function and
gives users control over the level of resampling by specifying the
number of samples to generate. If this parameter is left unspecified,
the function defaults to creating a significantly denser data set by
multiplying the number of rows in the data set by 1000. If the user
inputs the <code>filter_by</code> parameter, the resampling will use the
filtered data as if it represents the whole data set.</p>
<div id="here-are-some-ways-to-use-it" class="section level3">
<h3>Here are some ways to use it:</h3>
<div id="resampling-the-whole-data-set-with-no-other-parameters" class="section level4">
<h4>Resampling the whole data set with no other parameters</h4>
<p>This is the most basic way to use this function. It will default
multiplying the number of rows in the entire data set (~25,000) by 1000.
It should only be used when the data set it small and limited in
relation to the geographic area that is covered.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="fu">resample_heatmap</span>(</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>  <span class="at">data =</span> my_data, </span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>  <span class="at">lat_col =</span> <span class="st">&quot;latitude&quot;</span>, </span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>  <span class="at">lon_col =</span> <span class="st">&quot;longitude&quot;</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>  )</span></code></pre></div>
</div>
<div id="resampling-the-filtered-data-set-without-n_samples-parameter" class="section level4">
<h4>Resampling the filtered data set without <code>n_samples</code>
parameter</h4>
<p>The function will now multiply the number of rows that have value
specified in the <code>filter_by</code> parameter in the column
identified by the <code>col_data</code> parameter by 1000. In this
example, the function is filtering the data set to only the rows that
contain <code>Homicide</code> as the value in the column
<code>offense</code>. Thus, the data set is reduced to ~150 rows from
the original ~25,000. Since the <code>n_sample</code> parameter was not
used, the function will multiply the ~150 rows by 1000. The rest of the
function will run as if <code>n_samples</code> was defined as
~150,000.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="fu">resample_heatmap</span>(</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>  <span class="at">data =</span> my_data, </span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>  <span class="at">lat_col =</span> <span class="st">&quot;latitude&quot;</span>, </span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>  <span class="at">lon_col =</span> <span class="st">&quot;longitude&quot;</span>,</span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>  <span class="at">col_data =</span> <span class="st">&quot;offense&quot;</span>, </span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>  <span class="at">filter_by =</span> <span class="st">&quot;Homicide&quot;</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>  )</span></code></pre></div>
</div>
<div id="resampling-the-filtered-data-set-with-n_samples-parameter-and-basemap" class="section level4">
<h4>Resampling the filtered data set with <code>n_samples</code>
parameter and basemap</h4>
<p>With the addition of the <code>n_sample</code> parameter, the
function no longer multiplies the number of rows with the
<code>filter_by</code> value by 1000. In this example, the function is
filtering the data set to only the rows that contain
<code>Homicide</code> as the value in the column <code>offense</code>.
Thus, the data set is reduced to ~150 rows from the original ~25,000.
Since the <code>n_sample</code> parameter was used, the function
resamples the ~150 original rows a total of 20,000 times. This parameter
is useful when the optional filter results in a very small subset of
data. Lastly, in this example the parameter for <code>basemap</code> is
also used, so the resulting heatmap will be overlaid on
<code>my_basemap</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="fu">resample_heatmap</span>(</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>  <span class="at">data =</span> my_data, </span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>  <span class="at">lat_col =</span> <span class="st">&quot;latitude&quot;</span>, </span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>  <span class="at">lon_col =</span> <span class="st">&quot;longitude&quot;</span>, </span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>  <span class="at">col_data =</span> <span class="st">&quot;offense&quot;</span>, </span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>  <span class="at">filter_by =</span> <span class="st">&quot;Homicide&quot;</span>, </span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a>  <span class="at">n_samples =</span> <span class="dv">20000</span>,</span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a>  <span class="at">basemap =</span> my_basemap</span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>  )</span></code></pre></div>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
