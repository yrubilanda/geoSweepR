n_samples <- 1000 * nrow(data)
}
#### Step 1.1.2.b: Resample filtered data with either a specified n_sample or default n_sample. (if specified, you might have to play around with this number)
if(n_samples > nrow(data)){
data <- dplyr::slice_sample(data, n = n_samples, replace = TRUE)
}
} else {
## Step 1.2: No Filter on Data
### Step 1.2.1: Resampling
#### Step 1.2.1.a: Set default if n_samples is NULL. Default is to multiply the total number of rows in data set by 1000.
if (is.null(n_samples)){
n_samples <- 1000 * nrow(data)
}
#### Step 1.2.1.b: Resample the entire dataset by `n_samples`.
if (n_samples > nrow(data)) {
data <- data[sample(1:nrow(data), size = n_samples, replace = TRUE), ]
}
}
# Step 2: Coordinate Reference System Argument
## Step 2.1: Make sure the coordinate reference system is used correctly. If no coordinate system is specified, the default is WGS 84.
if (is.na(sf::st_crs(input_crs))) {
stop("Invalid CRS: please provide a valid EPSG code or PROJ string.")
}
# Step 3: Convert to Spatial Object
# Use latitude and longitude columns to convert to spatial object using {sf}.
#`coords` tells the function which columns are latitude and longitude.
# `crs = input_crs` calls the coordinate reference system. If no CRS is specified, it defaults to WGS 84.
# `remove = FALSE` keeps the latitude and longitude in the table.
data_sf <- sf::st_as_sf(
data,
coords = c(lon_col, lat_col),
crs = input_crs,
remove = FALSE
)
# Step 4: Handle Basemap
## Step 4.1: Basemap Present
if (!is.null(basemap)) {
crs_target <- terra::crs(basemap)
data_proj <- sf::st_transform(data_sf, crs = crs_target)
}
## Step 4.2: No Basemap. Defaults to showing the graph on its own.
else{
data_proj <- data_sf
}
# Step 5: Extract Coordinates
data_proj <- cbind(data_proj, sf::st_coordinates(data_proj))
## Step 5.1: Rename for the plot.
names(data_proj)[names(data_proj) == "X"] <- "x"
names(data_proj)[names(data_proj) == "Y"] <- "y"
# Step 6: Create Plot
## Step 6.1: Create basic plot.
p <- ggplot2::ggplot()
## Step 6.2: Include basemap in the plot if it is provided.
if(!is.null(basemap)) {
p <- p + ggspatial::layer_spatial(basemap)
}
## Step 6.3: Include layer with the heatmap.
p <- p +
ggplot2::stat_density_2d(
data = data_proj,
ggplot2::aes(x = x, y = y, fill = after_stat(level)),
geom = "polygon",
contour = TRUE,
alpha = 0.5
) +
ggplot2::scale_fill_viridis_c(option = "cividis") +
ggplot2::labs(
title = if (!is.null(filter_by)) paste("Resampled Heatmap:", filter_by) else "Resampled Heatmap",
x = "Longitude",
y = "Latitude"
) +
ggplot2::theme_minimal()
## Step 6.4: Set coordinate reference system for basemap
if(!is.null(basemap)) {
p <- p + ggplot2::coord_sf(crs = sf::st_crs(basemap))
}
# Step 7: Generate the final plot as the output of the function.
return(p)
}
#RESAMPLE TRY
p_resample <- resample_heatmap(data = d, lat_col = "latitude", lon_col = "longitude",
col_data = "offense",
filter_by = "Homicide",
n_samples = 10000,
basemap = raster_map)
p_resample
bbox <- sf::st_as_sfc(
sf::st_bbox(c(
xmin = -77.10,
xmax = -76.90,
ymin = 38.80,
ymax = 39.00
), crs = st_crs(4326))
)
raster_map <- get_tiles(bbox, provider = "CartoDB.Positron", crop = TRUE)
resample_heatmap <- function(data, lat_col, lon_col, n_samples = NULL, col_data = NULL, filter_by = NULL, basemap = NULL, input_crs = 4326){
# Step 1: Filters and Sampling
## Step 1.1: Optional Filters
### Step 1.1.1: Check if specified and filter according to column and value
if (!is.null(filter_by) && !is.null(col_data)) {
data <- dplyr::filter(data, .data[[col_data]] == filter_by)
#### Step 1.1.1.a: Check that there is still data after filtering. If there is no data, stop execution.
if (nrow(data) == 0){
stop("No data left after filtering. Check your col_data and filter_by values.")
}
### Step 1.1.2: Resampling filtered data
#### Step 1.1.2.a: Set default if n_samples is NULL. Default if to multiply the number of rows by 1000.
if (is.null(n_samples)){
n_samples <- 1000 * nrow(data)
}
#### Step 1.1.2.b: Resample filtered data with either a specified n_sample or default n_sample. (if specified, you might have to play around with this number)
if(n_samples > nrow(data)){
data <- dplyr::slice_sample(data, n = n_samples, replace = TRUE)
}
} else {
## Step 1.2: No Filter on Data
### Step 1.2.1: Resampling
#### Step 1.2.1.a: Set default if n_samples is NULL. Default is to multiply the total number of rows in data set by 1000.
if (is.null(n_samples)){
n_samples <- 1000 * nrow(data)
}
#### Step 1.2.1.b: Resample the entire dataset by `n_samples`.
if (n_samples > nrow(data)) {
data <- data[sample(1:nrow(data), size = n_samples, replace = TRUE), ]
}
}
# Step 2: Coordinate Reference System Argument
## Step 2.1: Make sure the coordinate reference system is used correctly. If no coordinate system is specified, the default is WGS 84.
if (is.na(sf::st_crs(input_crs))) {
stop("Invalid CRS: please provide a valid EPSG code or PROJ string.")
}
# Step 3: Convert to Spatial Object
# Use latitude and longitude columns to convert to spatial object using {sf}.
#`coords` tells the function which columns are latitude and longitude.
# `crs = input_crs` calls the coordinate reference system. If no CRS is specified, it defaults to WGS 84.
# `remove = FALSE` keeps the latitude and longitude in the table.
data_sf <- sf::st_as_sf(
data,
coords = c(lon_col, lat_col),
crs = input_crs,
remove = FALSE
)
# Step 4: Handle Basemap
## Step 4.1: Basemap Present
if (!is.null(basemap)) {
crs_target <- terra::crs(basemap)
data_proj <- sf::st_transform(data_sf, crs = crs_target)
}
## Step 4.2: No Basemap. Defaults to showing the graph on its own.
else{
data_proj <- data_sf
}
# Step 5: Extract Coordinates
data_proj <- cbind(data_proj, sf::st_coordinates(data_proj))
## Step 5.1: Rename for the plot.
names(data_proj)[names(data_proj) == "X"] <- "x"
names(data_proj)[names(data_proj) == "Y"] <- "y"
# Step 6: Create Plot
## Step 6.1: Create basic plot.
p <- ggplot2::ggplot()
## Step 6.2: Include basemap in the plot if it is provided.
if(!is.null(basemap)) {
p <- p + ggspatial::layer_spatial(basemap)
}
## Step 6.3: Include layer with the heatmap.
p <- p +
ggplot2::stat_density_2d(
data = data_proj,
ggplot2::aes(x = x, y = y, fill = after_stat(level)),
geom = "polygon",
contour = TRUE,
alpha = 0.5
) +
ggplot2::scale_fill_viridis_c(option = "cividis") +
ggplot2::labs(
title = if (!is.null(filter_by)) paste("Resampled Heatmap:", filter_by) else "Resampled Heatmap",
x = "Longitude",
y = "Latitude"
) +
ggplot2::theme_minimal()
## Step 6.4: Set coordinate reference system for basemap
if(!is.null(basemap)) {
p <- p + ggplot2::coord_sf(crs = sf::st_crs(basemap))
}
# Step 7: Generate the final plot as the output of the function.
return(p)
}
#RESAMPLE TRY
p_resample <- resample_heatmap(data = d, lat_col = "latitude", lon_col = "longitude",
col_data = "offense",
filter_by = "Homicide",
n_samples = 10000,
basemap = raster_map)
p_resample
# TEST
p_kriging <- density_kriging(d, lon_col = "longitude", lat_col = "latitude", basemap = raster_map)
p_kriging
#MAKE HEATMAP TRY
make_heatmap <- function(data, lat_col, lon_col, col_data = NULL, filter_by = NULL, basemap = NULL, input_crs = 4326) {
# If both a column name and a value to filter by are given, filter the data down to just that value
if (!is.null(filter_by) && !is.null(col_data)) {
data <- dplyr::filter(data, .data[[col_data]] == filter_by)
}
# Check to make sure the CRS system is used correctly
if (is.na(st_crs(input_crs))) {
stop("Invalid CRS: please provide a valid EPSG code or PROJ string.")
}
# Turn your data frame into a spatial object (sf) using latitude and longitude columns
data_sf <- sf::st_as_sf(
data,
coords = c(lon_col, lat_col),  # tell sf which columns are longitude and latitude
crs = input_crs,                    # default to WGS 84, unless specified in the function
remove = FALSE                 # keep the original lat/lon columns in the table just in case
)
# If the user provided a basemap, match the coordinate system to the map
if (!is.null(basemap)) {
crs_target <- terra::crs(basemap)                         # get the map’s coordinate system
data_proj <- sf::st_transform(data_sf, crs = crs_target)  # reproject your points to match the map
} else {
data_proj <- data_sf  # if no map, just keep the original projection (WGS 84)
}
# Add X and Y columns (in projected units) so we can use them in the plot
data_proj <- cbind(data_proj, sf::st_coordinates(data_proj))
names(data_proj)[names(data_proj) == "X"] <- "x"  # rename for plotting
names(data_proj)[names(data_proj) == "Y"] <- "y"
# Start building the plot with ggplot
p <- ggplot2::ggplot()
# If we were given a basemap, add it to the plot first (as the background layer)
if (!is.null(basemap)) {
p <- p + ggspatial::layer_spatial(basemap)
}
# Add the heatmap layer — this shows areas with more data points as more intense
p <- p +
ggplot2::stat_density_2d(
data = data_proj,  # the projected spatial data with x and y columns
ggplot2::aes(x = x, y = y, fill = ggplot2::after_stat(level)),  # use density level as the fill
geom = "polygon",   # draw filled contour polygons
contour = TRUE,     # draw contour lines
alpha = 0.5         # make it semi-transparent so you can see the basemap if you added one
) +
ggplot2::scale_fill_viridis_c(option = "cividis") +  # use a colorblind-friendly color scale
ggplot2::labs(
title = if (!is.null(filter_by)) paste("Heatmap:", filter_by) else "Heatmap",  # add a title
x = "Longitude", y = "Latitude"  # label the axes
) +
ggplot2::theme_minimal()  # use a clean minimal background theme
# If there was a basemap, set the plot's coordinate system to match the map
if (!is.null(basemap)) {
p <- p + ggplot2::coord_sf(crs = sf::st_crs(basemap))
}
return(p)  # Return the finished heatmap plot
}
#MAKE HEATMAP EXAMPLE
p_heatmap <- make_heatmap(d, lat_col = "latitude", lon_col = "longitude", basemap = raster_map)
p_heatmap
devtools::load_all()
devtools::load_all()
library(gstat)
usethis::use_package("gstat")
devtools::load_all()
my_data <- read.csv(system.file("extdata", "dc_sample.csv", package = "geoSweepR"))
xmax = -76.90,ymin = 38.80,
# Save my_basemap.tif to inst/extdata/
bbox <- sf::st_as_sfc(
sf::st_bbox(c(
xmin = -77.10,
xmax = -76.90,
ymin = 38.80,
ymax = 39.00
), crs = st_crs(4326))
)
my_basemap <- get_tiles(bbox, provider = "CartoDB.Positron", crop = TRUE)
dir.create("inst/extdata", showWarnings = FALSE, recursive = TRUE)
terra::writeRaster(my_basemap, "inst/extdata/my_basemap.tif", overwrite = TRUE)
my_data <- read.csv(system.file("extdata", "dc_sample.csv", package = "geoSweepR"))
my_basemap <- terra::rast(system.file("extdata", "my_basemap.tif", package = "geoSweepR"))
devtools::load_all()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
install.packages(c("terra", "sf", "gstat", "dplyr", "ggplot2", "ggspatial", "rlang"))
library(terra)
library(sf)
library(gstat)
library(dplyr)
library(ggplot2)
library(ggspatial)
library(rlang)
devtools::check()
devtools::check()
usethis::use_package("readr", type = "Suggests")
usethis::use_package("maptiles", type = "Suggests")
sessionInfo()
rmarkdown::render("vignettes/intro-to-geoSweepR.Rmd")
rmarkdown::render("vignettes/intro-to-geoSweepR.Rmd")
class(my_data)
names(my_data)
unique(my_data$offense)
test <- d %>%
make_heatmap(
data = my_data,            # your dataset with coordinates and optional filter column
lat_col = "latitude",      # name of the latitude column
lon_col = "longitude",     # name of the longitude column
col_data = "offense",      # column to filter by (can be type, category, etc.)
filter_by = "Robbery",     # specific value to filter for (e.g., "Robbery")
basemap = my_basemap       # the basemap image to use as a background (optional)
)
unique(trimws(my_data$offense))
filtered_data <- dplyr::filter(my_data, offense == "Robbery")
print(head(filtered_data))
make_heatmap(
data = my_data,           # your full dataset (must have lat/lon columns)
lat_col = "latitude",  # column that holds the latitude values
lon_col = "longitude", # column that holds the longitude values
col_data = NULL,       # you also can just leave this blank so just do not write in
filter_by = NULL,
basemap = NULL
)
make_heatmap(
+     data = my_data,           # your full dataset (must have lat/lon columns)
make_heatmap(
data = my_data,           # your full dataset (must have lat/lon columns)
lat_col = "latitude",  # column that holds the latitude values
lon_col = "longitude", # column that holds the longitude values
col_data = NULL,       # you also can just leave this blank so just do not write in
filter_by = NULL,
basemap = NULL
)
make_heatmap(
data = my_data,          # your dataset (must include lat/lon columns)
lat_col = "latitude", # the column in your data that has latitude values
lon_col = "longitude",# the column that has longitude values
col_data = "offense", # this is the column we're filtering on (like type or category of data)
filter_by = "Robbery" # only include rows where offense == "Robbery"
)
make_heatmap(
data = my_data,            # your dataset with coordinates and optional filter column
lat_col = "latitude",      # name of the latitude column
lon_col = "longitude",     # name of the longitude column
col_data = "offense",      # column to filter by (can be type, category, etc.)
filter_by = "Robbery",     # specific value to filter for (e.g., "Robbery")
basemap = my_basemap       # the basemap image to use as a background (optional)
)
# Now use the heatmap function!
# This draws a density map of only "Robbery" incidents from the "offense" column,
# and overlays it on the sample basemap
make_heatmap(
data = my_data,            # your dataset with coordinates and optional filter column
lat_col = "latitude",      # name of the latitude column
lon_col = "longitude",     # name of the longitude column
col_data = "offense",      # column to filter by (can be type, category, etc.)
filter_by = "Homicide",     # specific value to filter for (e.g., "Robbery")
basemap = my_basemap       # the basemap image to use as a background (optional)
)
Robbery
# Now use the heatmap function!
# This draws a density map of only "Robbery" incidents from the "offense" column,
# and overlays it on the sample basemap
make_heatmap(
data = my_data,            # your dataset with coordinates and optional filter column
lat_col = "latitude",      # name of the latitude column
lon_col = "longitude",     # name of the longitude column
col_data = "offense",      # column to filter by (can be type, category, etc.)
filter_by = "Robbery",     # specific value to filter for (e.g., "Robbery")
basemap = my_basemap       # the basemap image to use as a background (optional)
)
rmarkdown::render("vignettes/intro-to-geoSweepR.Rmd")
rmarkdown::render("vignettes/intro-to-geoSweepR.Rmd", clean = TRUE)
rmarkdown::render("vignettes/intro-to-geoSweepR.Rmd", clean = TRUE)
test_data <- data.frame(
latitude = c(38.9, 39.0),
longitude = c(-77.0, -77.1),
offense = c("Robbery", "Theft")
)
make_heatmap(test_data, lat_col = "latitude",
lon_col = "longitude",
col_data = "offense",
filter_by = "Robbery"
))
make_heatmap(test_data, lat_col = "latitude", lon_col = "longitude", col_data = "offense", filter_by = "Robbery")
make_heatmap(
data = test_data,
lat_col = "latitude",
lon_col = "longitude",
col_data = "offense",
filter_by = "Robbery"
)
sum(is.na(my_data$latitude))  # Check for NAs in latitude
sum(is.na(my_data$longitude))
sum(is.na(my_data$offense))
update.packages("ggplot2")
rmarkdown::render("vignettes/intro-to-geoSweepR.Rmd", clean = TRUE)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(geoSweepR)
# Load sample data (replace with your actual data if needed)
data_path <- system.file("extdata", "dc_sample.csv", package = "geoSweepR") #YOU NEED TO USE THE DUMMY DATA IN THE EXTDATA FOLDER! THIS IS CRISTINAS CLEAN DATA
my_data <- readr::read_csv(data_path, col_names = TRUE)
head(my_data)
my_basemap <- terra::rast(system.file("extdata", "my_basemap.tif", package = "geoSweepR"))
# This is the simplest version of the function — just make a heatmap of ALL your points
make_heatmap(
data = my_data,           # your full dataset (must have lat/lon columns)
lat_col = "latitude",  # column that holds the latitude values
lon_col = "longitude", # column that holds the longitude values
col_data = NULL,       # you also can just leave this blank so just do not write in
filter_by = NULL,
basemap = NULL
)
# NOTE:
# This does NOT filter by any category — it includes every row in your dataset.
# There's also no basemap in the background — just a clean heatmap showing areas with more data points.
# This is a great starting point if you just want to see the overall spatial density of your data.
# Call the heatmap function using just your point data — no basemap but you can filter by type within your column
make_heatmap(
data = my_data,          # your dataset (must include lat/lon columns)
lat_col = "latitude", # the column in your data that has latitude values
lon_col = "longitude",# the column that has longitude values
col_data = "offense", # this is the column we're filtering on (like type or category of data)
filter_by = "Robbery" # only include rows where offense == "Robbery"
)
# Now use the heatmap function!
# This draws a density map of only "Robbery" incidents from the "offense" column,
# and overlays it on the sample basemap
make_heatmap(
data = my_data,            # your dataset with coordinates and optional filter column
lat_col = "latitude",      # name of the latitude column
lon_col = "longitude",     # name of the longitude column
col_data = "offense",      # column to filter by (can be type, category, etc.)
filter_by = "Robbery",     # specific value to filter for (e.g., "Robbery")
basemap = my_basemap       # the basemap image to use as a background (optional)
)
# Basic version of the function, running the entire code at standard levels
density_kriging(
data = my_data,            # your full dataset (must have lat/lon columns)
lon_col = "longitude", # column that holds the latitude values
lat_col = "latitude",   # column that holds the longitude values
input_crs = 4326,             #CRS for the data region - Washington DC
col_data = NULL,        #you can also leave this and the following sections blank to produce the base result
filter_by = NULL,
grid_size = 500,
variogram_model = "Sph")
# NOTE:
# This does NOT filter by any category — it uses a count derived from your entire dataset.
# This is a good way to visualize how general trends in your data can be extrapolated beyond the recorded observation.
# Adjusted code displaying how using smaller grids could affect the data
density_kriging(
data = my_data,            # your full dataset (must have lat/lon columns)
lon_col = "longitude", # column that holds the latitude values
lat_col = "latitude",   # column that holds the longitude values
input_crs = 4326,             #CRS for the data region - Washington DC
grid_size = 250)
# NOTE:
# This still does NOT filter by any category — it uses a count derived from your entire dataset but uses smaller grid sizes to get more granular with the visualization
# This can be useful for smaller datasets and for visualizing boundaries
# You can filter by specific values in particular categorical variables
density_kriging(
data = my_data,            # your full dataset (must have lat/lon columns)
lon_col = "longitude", # column that holds the latitude values
lat_col = "latitude",   # column that holds the longitude values
input_crs = 4326,             #CRS for the data region - Washington DC
col_data = "offense",
filter_by = "Robbery")
# NOTE:
# This is a good way to visualize a specific categorical value or variable
resample_heatmap(
data = my_data,
lat_col = "latitude",
lon_col = "longitude"
)
getwd()
devtools::document()
?make_heatmap
?resample_heatmap
?density_kriging
usethis::use_mit_license("Rubi Landa")
devtools::load_all()
devtools::document()
devtools::install(build_vignettes = TRUE, upgrade = "never")
devtools::install(build_vignettes = TRUE)
library(geoSweepR)
vignette("geoSweepR")
devtools::install(build_vignettes = TRUE)
vignette(package = "geoSweepR")
vignette("intro-to-geoSweepR")
devtools::clean_vignettes()
devtools::install(build_vignettes = TRUE, force = TRUE)
vignette(package = "geoSweepR")
vignette("intro-to-geoSweepR")
system.file("doc", package = "geoSweepR")
list.files(system.file("doc", package = "geoSweepR"))
devtools::clean_vignettes()
devtools::install(build_vignettes = TRUE, force = TRUE)
vignette(package = "geoSweepR")
devtools::clean_vignettes()
devtools::install(build_vignettes = TRUE, force = TRUE)
vignette(package = "geoSweepR")
rmarkdown::render("vignettes/intro-to-geoSweepR.Rmd", output_format = "html_vignette")
