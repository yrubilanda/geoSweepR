devtools::load_all()
devtools::load_all()
library(gstat)
usethis::use_package("gstat")
devtools::load_all()
my_data <- read.csv(system.file("extdata", "dc_sample.csv", package = "geoSweepR"))
xmax = -76.90,ymin = 38.80,
# Save my_basemap.tif to inst/extdata/
bbox <- sf::st_as_sfc(
sf::st_bbox(c(
xmin = -77.10,
xmax = -76.90,
ymin = 38.80,
ymax = 39.00
), crs = st_crs(4326))
)
my_basemap <- get_tiles(bbox, provider = "CartoDB.Positron", crop = TRUE)
dir.create("inst/extdata", showWarnings = FALSE, recursive = TRUE)
terra::writeRaster(my_basemap, "inst/extdata/my_basemap.tif", overwrite = TRUE)
my_data <- read.csv(system.file("extdata", "dc_sample.csv", package = "geoSweepR"))
my_basemap <- terra::rast(system.file("extdata", "my_basemap.tif", package = "geoSweepR"))
devtools::load_all()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
install.packages(c("terra", "sf", "gstat", "dplyr", "ggplot2", "ggspatial", "rlang"))
library(terra)
library(sf)
library(gstat)
library(dplyr)
library(ggplot2)
library(ggspatial)
library(rlang)
devtools::check()
devtools::check()
usethis::use_package("readr", type = "Suggests")
usethis::use_package("maptiles", type = "Suggests")
sessionInfo()
rmarkdown::render("vignettes/intro-to-geoSweepR.Rmd")
rmarkdown::render("vignettes/intro-to-geoSweepR.Rmd")
class(my_data)
names(my_data)
unique(my_data$offense)
test <- d %>%
make_heatmap(
data = my_data,            # your dataset with coordinates and optional filter column
lat_col = "latitude",      # name of the latitude column
lon_col = "longitude",     # name of the longitude column
col_data = "offense",      # column to filter by (can be type, category, etc.)
filter_by = "Robbery",     # specific value to filter for (e.g., "Robbery")
basemap = my_basemap       # the basemap image to use as a background (optional)
)
unique(trimws(my_data$offense))
filtered_data <- dplyr::filter(my_data, offense == "Robbery")
print(head(filtered_data))
make_heatmap(
data = my_data,           # your full dataset (must have lat/lon columns)
lat_col = "latitude",  # column that holds the latitude values
lon_col = "longitude", # column that holds the longitude values
col_data = NULL,       # you also can just leave this blank so just do not write in
filter_by = NULL,
basemap = NULL
)
make_heatmap(
+     data = my_data,           # your full dataset (must have lat/lon columns)
make_heatmap(
data = my_data,           # your full dataset (must have lat/lon columns)
lat_col = "latitude",  # column that holds the latitude values
lon_col = "longitude", # column that holds the longitude values
col_data = NULL,       # you also can just leave this blank so just do not write in
filter_by = NULL,
basemap = NULL
)
make_heatmap(
data = my_data,          # your dataset (must include lat/lon columns)
lat_col = "latitude", # the column in your data that has latitude values
lon_col = "longitude",# the column that has longitude values
col_data = "offense", # this is the column we're filtering on (like type or category of data)
filter_by = "Robbery" # only include rows where offense == "Robbery"
)
make_heatmap(
data = my_data,            # your dataset with coordinates and optional filter column
lat_col = "latitude",      # name of the latitude column
lon_col = "longitude",     # name of the longitude column
col_data = "offense",      # column to filter by (can be type, category, etc.)
filter_by = "Robbery",     # specific value to filter for (e.g., "Robbery")
basemap = my_basemap       # the basemap image to use as a background (optional)
)
# Now use the heatmap function!
# This draws a density map of only "Robbery" incidents from the "offense" column,
# and overlays it on the sample basemap
make_heatmap(
data = my_data,            # your dataset with coordinates and optional filter column
lat_col = "latitude",      # name of the latitude column
lon_col = "longitude",     # name of the longitude column
col_data = "offense",      # column to filter by (can be type, category, etc.)
filter_by = "Homicide",     # specific value to filter for (e.g., "Robbery")
basemap = my_basemap       # the basemap image to use as a background (optional)
)
Robbery
# Now use the heatmap function!
# This draws a density map of only "Robbery" incidents from the "offense" column,
# and overlays it on the sample basemap
make_heatmap(
data = my_data,            # your dataset with coordinates and optional filter column
lat_col = "latitude",      # name of the latitude column
lon_col = "longitude",     # name of the longitude column
col_data = "offense",      # column to filter by (can be type, category, etc.)
filter_by = "Robbery",     # specific value to filter for (e.g., "Robbery")
basemap = my_basemap       # the basemap image to use as a background (optional)
)
rmarkdown::render("vignettes/intro-to-geoSweepR.Rmd")
rmarkdown::render("vignettes/intro-to-geoSweepR.Rmd", clean = TRUE)
rmarkdown::render("vignettes/intro-to-geoSweepR.Rmd", clean = TRUE)
test_data <- data.frame(
latitude = c(38.9, 39.0),
longitude = c(-77.0, -77.1),
offense = c("Robbery", "Theft")
)
make_heatmap(test_data, lat_col = "latitude",
lon_col = "longitude",
col_data = "offense",
filter_by = "Robbery"
))
make_heatmap(test_data, lat_col = "latitude", lon_col = "longitude", col_data = "offense", filter_by = "Robbery")
make_heatmap(
data = test_data,
lat_col = "latitude",
lon_col = "longitude",
col_data = "offense",
filter_by = "Robbery"
)
sum(is.na(my_data$latitude))  # Check for NAs in latitude
sum(is.na(my_data$longitude))
sum(is.na(my_data$offense))
update.packages("ggplot2")
rmarkdown::render("vignettes/intro-to-geoSweepR.Rmd", clean = TRUE)
# Load sample data (replace with your actual data if needed)
data_path <- system.file("extdata", "dc_sample.csv", package = "geoSweepR") #YOU NEED TO USE THE DUMMY DATA IN THE EXTDATA FOLDER! THIS IS CRISTINAS CLEAN DATA
my_data <- readr::read_csv(data_path, col_names = TRUE)
my_basemap <- terra::rast(system.file("extdata", "my_basemap.tif", package = "geoSweepR"))
my_data <- readr::read_csv(data_path, col_names = TRUE)
# Load sample data (replace with your actual data if needed)
data_path <- system.file("extdata", "dc_sample.csv", package = "geoSweepR") #YOU NEED TO USE THE DUMMY DATA IN THE EXTDATA FOLDER! THIS IS CRISTINAS CLEAN DATA
my_data <- readr::read_csv(data_path, col_names = TRUE)
system.file("extdata", package = "geoSweepR")
list.files(system.file("extdata", package = "geoSweepR"))
getwd()
# Load sample data (replace with your actual data if needed)
data_path <- system.file("extdata", "dc_sample.csv", package = "geoSweepR") #YOU NEED TO USE THE DUMMY DATA IN THE EXTDATA FOLDER! THIS IS CRISTINAS CLEAN DATA
my_data <- readr::read_csv(data_path, col_names = TRUE)
devtools::install()
# Load sample data (replace with your actual data if needed)
data_path <- system.file("extdata", "dc_sample.csv", package = "geoSweepR") #YOU NEED TO USE THE DUMMY DATA IN THE EXTDATA FOLDER! THIS IS CRISTINAS CLEAN DATA
my_data <- readr::read_csv(data_path, col_names = TRUE)
head(my_data)
my_basemap <- terra::rast(system.file("extdata", "my_basemap.tif", package = "geoSweepR"))
View(my_data)
sum(my_data$offense == "Homicide")
resample_heatmap(
data = my_data,
lat_col = "latitude",
lon_col = "longitude",
col_data = "offense",
filter_by = "Homicide",
n_samples = 200)
resample_heatmap <- function(data, lat_col, lon_col, n_samples = NULL, col_data = NULL, filter_by = NULL, basemap = NULL, input_crs = 4326){
# Step 1: Filters and Sampling
## Step 1.1: Optional Filters
### Step 1.1.1: Check if specified and filter according to column and value
if (!is.null(filter_by) && !is.null(col_data)) {
data <- dplyr::filter(data, .data[[col_data]] == filter_by)
#### Step 1.1.1.a: Check that there is still data after filtering. If there is no data, stop execution.
if (nrow(data) == 0){
stop("No data left after filtering. Check your col_data and filter_by values.")
}
### Step 1.1.2: Resampling filtered data
#### Step 1.1.2.a: Set default if n_samples is NULL. Default if to multiply the number of rows by 1000.
if (is.null(n_samples)){
n_samples <- 1000 * nrow(data)
}
#### Step 1.1.2.b: Resample filtered data with either a specified n_sample or default n_sample. (if specified, you might have to play around with this number)
if(n_samples > nrow(data)){
data <- dplyr::slice_sample(data, n = n_samples, replace = TRUE)
}
} else {
## Step 1.2: No Filter on Data
### Step 1.2.1: Resampling
#### Step 1.2.1.a: Set default if n_samples is NULL. Default is to multiply the total number of rows in data set by 1000.
if (is.null(n_samples)){
n_samples <- 1000 * nrow(data)
}
#### Step 1.2.1.b: Resample the entire dataset by `n_samples`.
if (n_samples > nrow(data)) {
data <- data[sample(1:nrow(data), size = n_samples, replace = TRUE), ]
}
}
# Step 2: Coordinate Reference System Argument
## Step 2.1: Make sure the coordinate reference system is used correctly. If no coordinate system is specified, the default is WGS 84.
if (is.na(sf::st_crs(input_crs))) {
stop("Invalid CRS: please provide a valid EPSG code or PROJ string.")
}
# Step 3: Convert to Spatial Object
# Use latitude and longitude columns to convert to spatial object using {sf}.
#`coords` tells the function which columns are latitude and longitude.
# `crs = input_crs` calls the coordinate reference system. If no CRS is specified, it defaults to WGS 84.
# `remove = FALSE` keeps the latitude and longitude in the table.
data_sf <- sf::st_as_sf(
data,
coords = c(lon_col, lat_col),
crs = input_crs,
remove = FALSE
)
# Step 4: Handle Basemap
## Step 4.1: Basemap Present
if (!is.null(basemap)) {
crs_target <- terra::crs(basemap)
data_proj <- sf::st_transform(data_sf, crs = crs_target)
}
## Step 4.2: No Basemap. Defaults to showing the graph on its own.
else{
data_proj <- data_sf
}
# Step 5: Extract Coordinates
data_proj <- cbind(data_proj, sf::st_coordinates(data_proj))
## Step 5.1: Rename for the plot.
names(data_proj)[names(data_proj) == "X"] <- "x"
names(data_proj)[names(data_proj) == "Y"] <- "y"
# Step 6: Create Plot
## Step 6.1: Create basic plot.
p <- ggplot2::ggplot()
## Step 6.2: Include basemap in the plot if it is provided.
if(!is.null(basemap)) {
p <- p + ggspatial::layer_spatial(basemap)
}
## Step 6.3: Include layer with the heatmap.
p <- p +
ggplot2::stat_density_2d(
data = data_proj,
ggplot2::aes(x = x, y = y, fill = after_stat(level)),
geom = "polygon",
contour = TRUE,
alpha = 0.5
) +
ggplot2::scale_fill_viridis_c(option = "cividis") +
ggplot2::labs(
title = if (!is.null(filter_by)) paste("Resampled Heatmap:", filter_by) else "Resampled Heatmap",
x = "Longitude",
y = "Latitude"
) +
ggplot2::theme_minimal()
## Step 6.4: Set coordinate reference system for basemap
if(!is.null(basemap)) {
p <- p + ggplot2::coord_sf(crs = sf::st_crs(basemap))
}
# Step 7: Generate the final plot as the output of the function.
return(p)
}
#RESAMPLE TRY
p_resample <- resample_heatmap(
data = my_data,
lat_col = "latitude",
lon_col = "longitude",
col_data = "offense",
filter_by = "Homicide",
n_samples = 200)
p_resample
rlang::last_trace()
rlang::last_trace(drop = FALSE)
devtools::load_all()
my_basemap <- get_tiles(bbox, provider = "CartoDB.Positron", crop = TRUE)
resample_heatmap <- function(data, lat_col, lon_col, n_samples = NULL, col_data = NULL, filter_by = NULL, basemap = NULL, input_crs = 4326){
# Step 1: Filters and Sampling
## Step 1.1: Optional Filters
### Step 1.1.1: Check if specified and filter according to column and value
if (!is.null(filter_by) && !is.null(col_data)) {
data <- dplyr::filter(data, .data[[col_data]] == filter_by)
#### Step 1.1.1.a: Check that there is still data after filtering. If there is no data, stop execution.
if (nrow(data) == 0){
stop("No data left after filtering. Check your col_data and filter_by values.")
}
### Step 1.1.2: Resampling filtered data
#### Step 1.1.2.a: Set default if n_samples is NULL. Default if to multiply the number of rows by 1000.
if (is.null(n_samples)){
n_samples <- 1000 * nrow(data)
}
#### Step 1.1.2.b: Resample filtered data with either a specified n_sample or default n_sample. (if specified, you might have to play around with this number)
if(n_samples > nrow(data)){
data <- dplyr::slice_sample(data, n = n_samples, replace = TRUE)
}
} else {
## Step 1.2: No Filter on Data
### Step 1.2.1: Resampling
#### Step 1.2.1.a: Set default if n_samples is NULL. Default is to multiply the total number of rows in data set by 1000.
if (is.null(n_samples)){
n_samples <- 1000 * nrow(data)
}
#### Step 1.2.1.b: Resample the entire dataset by `n_samples`.
if (n_samples > nrow(data)) {
data <- data[sample(1:nrow(data), size = n_samples, replace = TRUE), ]
}
}
# Step 2: Coordinate Reference System Argument
## Step 2.1: Make sure the coordinate reference system is used correctly. If no coordinate system is specified, the default is WGS 84.
if (is.na(sf::st_crs(input_crs))) {
stop("Invalid CRS: please provide a valid EPSG code or PROJ string.")
}
# Step 3: Convert to Spatial Object
# Use latitude and longitude columns to convert to spatial object using {sf}.
#`coords` tells the function which columns are latitude and longitude.
# `crs = input_crs` calls the coordinate reference system. If no CRS is specified, it defaults to WGS 84.
# `remove = FALSE` keeps the latitude and longitude in the table.
data_sf <- sf::st_as_sf(
data,
coords = c(lon_col, lat_col),
crs = input_crs,
remove = FALSE
)
# Step 4: Handle Basemap
## Step 4.1: Basemap Present
if (!is.null(basemap)) {
crs_target <- terra::crs(basemap)
data_proj <- sf::st_transform(data_sf, crs = crs_target)
}
## Step 4.2: No Basemap. Defaults to showing the graph on its own.
else{
data_proj <- data_sf
}
# Step 5: Extract Coordinates
data_proj <- cbind(data_proj, sf::st_coordinates(data_proj))
## Step 5.1: Rename for the plot.
names(data_proj)[names(data_proj) == "X"] <- "x"
names(data_proj)[names(data_proj) == "Y"] <- "y"
# Step 6: Create Plot
## Step 6.1: Create basic plot.
p <- ggplot2::ggplot()
## Step 6.2: Include basemap in the plot if it is provided.
if(!is.null(basemap)) {
p <- p + ggspatial::layer_spatial(basemap)
}
## Step 6.3: Include layer with the heatmap.
p <- p +
ggplot2::stat_density_2d(
data = data_proj,
ggplot2::aes(x = x, y = y, fill = after_stat(level)),
geom = "polygon",
contour = TRUE,
alpha = 0.5
) +
ggplot2::scale_fill_viridis_c(option = "cividis") +
ggplot2::labs(
title = if (!is.null(filter_by)) paste("Resampled Heatmap:", filter_by) else "Resampled Heatmap",
x = "Longitude",
y = "Latitude"
) +
ggplot2::theme_minimal()
## Step 6.4: Set coordinate reference system for basemap
if(!is.null(basemap)) {
p <- p + ggplot2::coord_sf(crs = sf::st_crs(basemap))
}
# Step 7: Generate the final plot as the output of the function.
return(p)
}
#RESAMPLE TRY
p_resample <- resample_heatmap(
data = my_data,
lat_col = "latitude",
lon_col = "longitude",
col_data = "offense",
filter_by = "Homicide",
n_samples = 200)
p_resample
# Step 7: Generate the final plot as the output of the function.
return(list(
plot = p,
resampled_data = data_proj
))
resample_heatmap <- function(data, lat_col, lon_col, n_samples = NULL, col_data = NULL, filter_by = NULL, basemap = NULL, input_crs = 4326){
# Step 1: Filters and Sampling
## Step 1.1: Optional Filters
### Step 1.1.1: Check if specified and filter according to column and value
if (!is.null(filter_by) && !is.null(col_data)) {
data <- dplyr::filter(data, .data[[col_data]] == filter_by)
#### Step 1.1.1.a: Check that there is still data after filtering. If there is no data, stop execution.
if (nrow(data) == 0){
stop("No data left after filtering. Check your col_data and filter_by values.")
}
### Step 1.1.2: Resampling filtered data
#### Step 1.1.2.a: Set default if n_samples is NULL. Default if to multiply the number of rows by 1000.
if (is.null(n_samples)){
n_samples <- 1000 * nrow(data)
}
#### Step 1.1.2.b: Resample filtered data with either a specified n_sample or default n_sample. (if specified, you might have to play around with this number)
if(n_samples > nrow(data)){
data <- dplyr::slice_sample(data, n = n_samples, replace = TRUE)
}
} else {
## Step 1.2: No Filter on Data
### Step 1.2.1: Resampling
#### Step 1.2.1.a: Set default if n_samples is NULL. Default is to multiply the total number of rows in data set by 1000.
if (is.null(n_samples)){
n_samples <- 1000 * nrow(data)
}
#### Step 1.2.1.b: Resample the entire dataset by `n_samples`.
if (n_samples > nrow(data)) {
data <- data[sample(1:nrow(data), size = n_samples, replace = TRUE), ]
}
}
# Step 2: Coordinate Reference System Argument
## Step 2.1: Make sure the coordinate reference system is used correctly. If no coordinate system is specified, the default is WGS 84.
if (is.na(sf::st_crs(input_crs))) {
stop("Invalid CRS: please provide a valid EPSG code or PROJ string.")
}
# Step 3: Convert to Spatial Object
# Use latitude and longitude columns to convert to spatial object using {sf}.
#`coords` tells the function which columns are latitude and longitude.
# `crs = input_crs` calls the coordinate reference system. If no CRS is specified, it defaults to WGS 84.
# `remove = FALSE` keeps the latitude and longitude in the table.
data_sf <- sf::st_as_sf(
data,
coords = c(lon_col, lat_col),
crs = input_crs,
remove = FALSE
)
# Step 4: Handle Basemap
## Step 4.1: Basemap Present
if (!is.null(basemap)) {
crs_target <- terra::crs(basemap)
data_proj <- sf::st_transform(data_sf, crs = crs_target)
}
## Step 4.2: No Basemap. Defaults to showing the graph on its own.
else{
data_proj <- data_sf
}
# Step 5: Extract Coordinates
data_proj <- cbind(data_proj, sf::st_coordinates(data_proj))
## Step 5.1: Rename for the plot.
names(data_proj)[names(data_proj) == "X"] <- "x"
names(data_proj)[names(data_proj) == "Y"] <- "y"
# Step 6: Create Plot
## Step 6.1: Create basic plot.
p <- ggplot2::ggplot()
## Step 6.2: Include basemap in the plot if it is provided.
if(!is.null(basemap)) {
p <- p + ggspatial::layer_spatial(basemap)
}
## Step 6.3: Include layer with the heatmap.
p <- p +
ggplot2::stat_density_2d(
data = data_proj,
ggplot2::aes(x = x, y = y, fill = after_stat(level)),
geom = "polygon",
contour = TRUE,
alpha = 0.5
) +
ggplot2::scale_fill_viridis_c(option = "cividis") +
ggplot2::labs(
title = if (!is.null(filter_by)) paste("Resampled Heatmap:", filter_by) else "Resampled Heatmap",
x = "Longitude",
y = "Latitude"
) +
ggplot2::theme_minimal()
## Step 6.4: Set coordinate reference system for basemap
if(!is.null(basemap)) {
p <- p + ggplot2::coord_sf(crs = sf::st_crs(basemap))
}
# Step 7: Generate the final plot as the output of the function.
return(list(
plot = p,
resampled_data = data_proj
))
}
#RESAMPLE TRY
p_resample <- resample_heatmap(
data = my_data,
lat_col = "latitude",
lon_col = "longitude",
col_data = "offense",
filter_by = "Homicide",
n_samples = 200)
p_resample
View(p_resample)
View(my_data)
View(p_resample$resampled_data)
#RESAMPLE TRY
p_resample <- resample_heatmap(
data = my_data,
lat_col = "latitude",
lon_col = "longitude",
col_data = "offense",
filter_by = "Homicide")
p_resample
p_resample
View(p_resample$resampled_data)
devtools::check()
devtools::check()
.Last.error
usethis::use_package("readr")
devtools::document()
devtools::check()
