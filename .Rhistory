usethis::use_github(protocol="https")
usethis::use_github(protocol = "https")
usethis::use_readme_md()
usethis::use_vignette("intro-to-geoSweepR")
#' @param crime_type Optional. Character string for crime type (e.g. "Assault"). If NULL, no filtering is applied.
#' @param basemap Optional. A raster object from maptiles::get_tiles(). Default is NULL.
#'
#' @return A ggplot2 object.
#' @export
#'
#' @examples
#' make_crime_heatmap(data, latitude, longitude)
#' make_crime_heatmap(data, latitude, longitude, type_col = offense, crime_type = "Assault")
#' make_crime_heatmap(data, latitude, longitude, basemap = my_map)
make_crime_heatmap <- function(data, lat_col, lon_col, type_col = NULL, crime_type = NULL, basemap = NULL) {
# If crime_type is not NULL, filter by crime type
if (!is.null(crime_type) && !is.null(type_col)) {
data <- dplyr::filter(data, {{ type_col }} == crime_type)
}
# Convert to sf
data_sf <- sf::st_as_sf(
data,
coords = c(as.character(substitute(lon_col)), as.character(substitute(lat_col))),
crs = 4326,
remove = FALSE
)
# Reproject and add x/y columns
if (!is.null(basemap)) {
crs_target <- terra::crs(basemap)
data_proj <- sf::st_transform(data_sf, crs = crs_target)
} else {
data_proj <- data_sf
}
data_proj <- cbind(data_proj, sf::st_coordinates(data_proj))
names(data_proj)[names(data_proj) == "X"] <- "x"
names(data_proj)[names(data_proj) == "Y"] <- "y"
# Build plot
p <- ggplot2::ggplot()
if (!is.null(basemap)) {
p <- p + ggspatial::layer_spatial(basemap)
}
p <- p +
ggplot2::stat_density_2d(
data = data_proj,
ggplot2::aes(x = x, y = y, fill = ggplot2::after_stat(level)),
geom = "polygon",
contour = TRUE,
alpha = 0.5
) +
ggplot2::scale_fill_viridis_c(option = "cividis") +
ggplot2::labs(
title = if (!is.null(crime_type)) paste("Crime Heatmap:", crime_type) else "Crime Heatmap",
x = "Longitude", y = "Latitude"
) +
ggplot2::theme_minimal()
if (!is.null(basemap)) {
p <- p + ggplot2::coord_sf(crs = sf::st_crs(basemap))
}
return(p)
}
make_heatmap <- function(data, lat_col, lon_col, col_data = NULL, filter_by = NULL, basemap = NULL) {
# If user provides a filter value and a column to filter on, narrow the data
if (!is.null(filter_by) && !is.null(col_data)) {
# Use dplyr to keep only rows where the value in col_data matches filter_by
data <- dplyr::filter(data, {{ col_data }} == filter_by)
}
# Convert the data into a spatial object using sf package
# This step turns your table into something that understands geographic coordinates
data_sf <- sf::st_as_sf(
data,
coords = c(as.character(substitute(lon_col)), as.character(substitute(lat_col))),  # Set longitude and latitude
crs = 4326,     # EPSG 4326 = WGS84, the standard GPS coordinate system
remove = FALSE  # Keep the original lat/lon columns in the table
)
# If the user provides a basemap, we match the projection of our points to that map
if (!is.null(basemap)) {
crs_target <- terra::crs(basemap)                       # Get the coordinate system of the map
data_proj <- sf::st_transform(data_sf, crs = crs_target)  # Transform points to match the map's coordinate system
} else {
data_proj <- data_sf  # If no map is given, just keep the original coordinate system
}
# Add X and Y (longitude and latitude) columns to the data for plotting
data_proj <- cbind(data_proj, sf::st_coordinates(data_proj))  # Extract x and y coords into their own columns
names(data_proj)[names(data_proj) == "X"] <- "x"  # Rename for ggplot compatibility
names(data_proj)[names(data_proj) == "Y"] <- "y"
# Create an empty ggplot object to start building the plot
p <- ggplot2::ggplot()
# If a basemap was provided, add it as a background layer to the plot
if (!is.null(basemap)) {
p <- p + ggspatial::layer_spatial(basemap)
}
# Add the 2D kernel density heatmap layer
# This layer calculates and displays where points are most concentrated
p <- p +
ggplot2::stat_density_2d(
data = data_proj,
ggplot2::aes(x = x, y = y, fill = ggplot2::after_stat(level)),  # Fill the map based on calculated density levels
geom = "polygon",    # Use filled shapes to represent areas of higher density
contour = TRUE,      # Draw contour lines around density areas
alpha = 0.5          # Slight transparency so underlying basemap (if any) shows through
) +
ggplot2::scale_fill_viridis_c(option = "cividis") +  # Use colorblind-friendly color scale
ggplot2::labs(
title = if (!is.null(filter_by)) paste("Heatmap:", filter_by) else "Heatmap",
x = "Longitude", y = "Latitude"
) +
ggplot2::theme_minimal()  # Use a clean, simple background style for the plot
# If using a basemap, make sure the axes are drawn using the same map projection
if (!is.null(basemap)) {
p <- p + ggplot2::coord_sf(crs = sf::st_crs(basemap))
}
return(p)  # Show the final heatmap
}
devtools::load_all()
library(geoSweepR)
# Load sample data (replace with your actual data if needed)
data_path <- system.file("extdata", "dc_sample.csv", package = "geoSweepR")
data <- read.csv(data_path)
head(data)
# Without basemap, without filter
make_heatmap(data, lat_col = latitude, lon_col = longitude)
# make_heatmap(my_data, lat_col = latitude, lon_col = longitude, col_data = type, filter_by = "Theft")
# make_heatmap(my_data, lat_col = latitude, lon_col = longitude, basemap = my_map)
make_heatmap(data, lat_col = latitude, lon_col = longitude, col_data = offense, filter_by = "Theft")
View(data)
# Load sample data (replace with your actual data if needed)
library(readr)
data_path <- system.file("extdata", "dc_sample.csv", package = "geoSweepR")
data <- read_csv(data_path, col_names = TRUE)
head(data)
# Without basemap, without filter
make_heatmap(data, lat_col = latitude, lon_col = longitude)
make_heatmap(data, lat_col = latitude, lon_col = longitude, col_data = offense, filter_by = "Theft")
make_heatmap(data, lat_col = latitude, lon_col = longitude, col_data = offense, filter_by = "Theft")
make_heatmap(data, lat_col = latitude, lon_col = longitude, col_data = offense, filter_by = "Theft")
make_heatmap(data, lat_col = latitude, lon_col = longitude, col_data = Offense, filter_by = "Theft")
```{r}
make_heatmap <- function(data, lat_col, lon_col, col_data = NULL, filter_by = NULL, basemap = NULL) {
# Filter the data if a filter and a category column are provided
if (!is.null(filter_by) && !is.null(col_data)) {
data <- dplyr::filter(data, .data[[col_data]] == filter_by)
}
# Convert to sf object using lat/lon column names (as strings)
data_sf <- sf::st_as_sf(
data,
coords = c(lon_col, lat_col),
crs = 4326,
remove = FALSE
)
# If a basemap is provided, transform coordinates to match it
if (!is.null(basemap)) {
crs_target <- terra::crs(basemap)
data_proj <- sf::st_transform(data_sf, crs = crs_target)
} else {
data_proj <- data_sf
}
# Add x/y coordinates for plotting
data_proj <- cbind(data_proj, sf::st_coordinates(data_proj))
names(data_proj)[names(data_proj) == "X"] <- "x"
names(data_proj)[names(data_proj) == "Y"] <- "y"
# Start the plot
p <- ggplot2::ggplot()
if (!is.null(basemap)) {
p <- p + ggspatial::layer_spatial(basemap)
}
p <- p +
ggplot2::stat_density_2d(
data = data_proj,
ggplot2::aes(x = x, y = y, fill = ggplot2::after_stat(level)),
geom = "polygon",
contour = TRUE,
alpha = 0.5
) +
ggplot2::scale_fill_viridis_c(option = "cividis") +
ggplot2::labs(
title = if (!is.null(filter_by)) paste("Heatmap:", filter_by) else "Heatmap",
x = "Longitude", y = "Latitude"
) +
ggplot2::theme_minimal()
if (!is.null(basemap)) {
p <- p + ggplot2::coord_sf(crs = sf::st_crs(basemap))
}
return(p)
}
devtools::load_all()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(geoSweepR)
# Load sample data (replace with your actual data if needed)
library(readr)
data_path <- system.file("extdata", "dc_sample.csv", package = "geoSweepR")
data <- read_csv(data_path, col_names = TRUE)
head(data)
# Without basemap, without filter
make_heatmap(data, lat_col = "latitude", lon_col = "longitude")
#' Create a 2D Kernel Density Heatmap with Optional Filter and Basemap
#'
#' This function generates a smooth heatmap from latitude and longitude coordinates.
#' Users can filter the data by a specific category (e.g., event type) and optionally overlay a basemap.
#' The function is flexible and works with any point-based spatial dataset.
#'
#' @param data A data frame that contains spatial point data (e.g., events, observations).
#' @param lat_col A string giving the name of the latitude column (e.g., "latitude").
#' @param lon_col A string giving the name of the longitude column (e.g., "longitude").
#' @param col_data (Optional) A string with the name of the column to filter by (e.g., "type" or "offense").
#' @param filter_by (Optional) A specific value to filter for in `col_data` (e.g., "Theft"). If NULL, all rows are used.
#' @param basemap (Optional) A basemap raster (from `maptiles::get_tiles()`) to include as background. Default is NULL.
#'
#' @return A ggplot2 object showing the kernel density heatmap, with or without a basemap.
#' @export
#'
#' @examples
#' # Heatmap of all points
#' make_heatmap(my_data, lat_col = "latitude", lon_col = "longitude")
#'
#' # Heatmap filtered by a specific type
#' make_heatmap(my_data, lat_col = "latitude", lon_col = "longitude",
#'              col_data = "offense", filter_by = "Theft")
#'
#' # Heatmap with a basemap layer
#' make_heatmap(my_data, lat_col = "latitude", lon_col = "longitude",
#'              basemap = my_basemap)
make_heatmap <- function(data, lat_col, lon_col, col_data = NULL, filter_by = NULL, basemap = NULL) {
# Filter the data if a filter and a category column are provided
if (!is.null(filter_by) && !is.null(col_data)) {
data <- dplyr::filter(data, .data[[col_data]] == filter_by)
}
# Convert to sf object using lat/lon column names (as strings)
data_sf <- sf::st_as_sf(
data,
coords = c(lon_col, lat_col),
crs = 4326,
remove = FALSE
)
# If a basemap is provided, transform coordinates to match it
if (!is.null(basemap)) {
crs_target <- terra::crs(basemap)
data_proj <- sf::st_transform(data_sf, crs = crs_target)
} else {
data_proj <- data_sf
}
# Add x/y coordinates for plotting
data_proj <- cbind(data_proj, sf::st_coordinates(data_proj))
names(data_proj)[names(data_proj) == "X"] <- "x"
names(data_proj)[names(data_proj) == "Y"] <- "y"
# Start the plot
p <- ggplot2::ggplot()
if (!is.null(basemap)) {
p <- p + ggspatial::layer_spatial(basemap)
}
p <- p +
ggplot2::stat_density_2d(
data = data_proj,
ggplot2::aes(x = x, y = y, fill = ggplot2::after_stat(level)),
geom = "polygon",
contour = TRUE,
alpha = 0.5
) +
ggplot2::scale_fill_viridis_c(option = "cividis") +
ggplot2::labs(
title = if (!is.null(filter_by)) paste("Heatmap:", filter_by) else "Heatmap",
x = "Longitude", y = "Latitude"
) +
ggplot2::theme_minimal()
if (!is.null(basemap)) {
p <- p + ggplot2::coord_sf(crs = sf::st_crs(basemap))
}
return(p)
}
devtools::load_all()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(geoSweepR)
# Load sample data (replace with your actual data if needed)
library(readr)
data_path <- system.file("extdata", "dc_sample.csv", package = "geoSweepR")
data <- read_csv(data_path, col_names = TRUE)
head(data)
# Without basemap, without filter
make_heatmap(data, lat_col = "latitude", lon_col = "longitude")
make_heatmap(data, lat_col = "latitude", lon_col = "longitude", col_data = "offense", filter_by = "Theft")
make_heatmap(data, lat_col = "latitude", lon_col = "longitude", col_data = "offense", filter_by = "Robbery")
# Heatmap with a basemap layer
make_heatmap(data,
lat_col = "latitude",
lon_col = "longitude",
col_data = "offense",
filter_by = "Robbery",
basemap = my_basemap)
#user needs to create their own basemap paramters:
library(maptiles)
library(sf)
# Create bounding box for basemap
bbox <- sf::st_as_sfc(sf::st_bbox(c(xmin = -77.05, xmax = -76.95, ymin = 38.85, ymax = 38.95), crs = sf::st_crs(4326)))
# Download basemap tiles
raster_map <- get_tiles(bbox, provider = "CartoDB.Positron")
# Heatmap with a basemap layer
make_heatmap(data,
lat_col = "latitude",
lon_col = "longitude",
col_data = "offense",
filter_by = "Robbery",
basemap = my_basemap)
#user needs to create their own basemap paramters:
library(maptiles)
library(sf)
# Create bounding box for basemap
bbox <- sf::st_as_sfc(sf::st_bbox(c(xmin = -77.05, xmax = -76.95, ymin = 38.85, ymax = 38.95), crs = sf::st_crs(4326)))
# Download basemap tiles
raster_map <- get_tiles(bbox, provider = "CartoDB.Positron")
# Heatmap with a basemap layer
make_heatmap(data,
lat_col = "latitude",
lon_col = "longitude",
col_data = "offense",
filter_by = "Robbery",
basemap = raster_map)
# Load libraries needed for getting a basemap and working with spatial data
library(maptiles)  # for downloading map tile layers like CartoDB
library(sf)        # for handling spatial objects like bounding boxes
# --- NOTE TO USERS ---
# The code below creates a basemap specifically for the DC crime data we're using in this example.
# The bbox values (xmin, xmax, ymin, ymax) define the area of interest in Washington, D.C.
#
# Our `make_heatmap()` function **does not generate this basemap** — you’ll need to set this up yourself
# based on the bounding box that makes sense for your own dataset (e.g., different city or region).
# This step is fully up to the user — the function just adds it if you provide one.
# Create a bounding box around the area you want to show on the map (in this case, part of D.C.)
bbox <- sf::st_as_sfc(
sf::st_bbox(c(
xmin = -77.05,  # western boundary of the area (longitude)
xmax = -76.95,  # eastern boundary (longitude)
ymin = 38.85,   # southern boundary (latitude)
ymax = 38.95    # northern boundary (latitude)
), crs = sf::st_crs(4326))  # Set the coordinate reference system (WGS84)
)
# Download the basemap tiles for that bounding box using the CartoDB Positron provider
# You could change the provider to something else like OpenStreetMap or Stamen if you want a different style
raster_map <- get_tiles(bbox, provider = "CartoDB.Positron")
# Now use the heatmap function!
# This draws a density map of only "Robbery" incidents from the "offense" column,
# and overlays it on the CartoDB basemap we just downloaded
make_heatmap(
data = data,               # your dataset with coordinates and optional filter column
lat_col = "latitude",      # name of the latitude column
lon_col = "longitude",     # name of the longitude column
col_data = "offense",      # column to filter by (can be type, category, etc.)
filter_by = "Robbery",     # specific value to filter for (e.g., "Robbery")
basemap = raster_map       # the basemap image to use as a background (optional)
)
# This is the simplest version of the function — just make a heatmap of ALL your points
make_heatmap(
data = data,               # your full dataset (must have lat/lon columns)
lat_col = "latitude",      # column that holds the latitude values
lon_col = "longitude", # column that holds the longitude values
col_data = NULL,
filter_by = NULL,
basemap = NULL
)
# NOTE:
# This does NOT filter by any category — it includes every row in your dataset.
# There's also no basemap in the background — just a clean heatmap showing areas with more data points.
# This is a great starting point if you just want to see the overall spatial density of your data.
make_heatmap <- function(data, lat_col, lon_col, col_data = NULL, filter_by = NULL, basemap = NULL) {
# If both a column name and a value to filter by are given, filter the data down to just that value
if (!is.null(filter_by) && !is.null(col_data)) {
data <- dplyr::filter(data, .data[[col_data]] == filter_by)
}
# Turn your data frame into a spatial object (sf) using latitude and longitude columns
data_sf <- sf::st_as_sf(
data,
coords = c(lon_col, lat_col),  # tell sf which columns are longitude and latitude
crs = 4326,                    # this is the standard GPS coordinate system (WGS 84)
remove = FALSE                 # keep the original lat/lon columns in the table just in case
)
# If the user provided a basemap, match the coordinate system to the map
if (!is.null(basemap)) {
crs_target <- terra::crs(basemap)                    # get the map’s coordinate system
data_proj <- sf::st_transform(data_sf, crs = crs_target)  # reproject your points to match the map
} else {
data_proj <- data_sf  # if no map, just keep the original projection (WGS 84)
}
# Add X and Y columns (in projected units) so we can use them in the plot
data_proj <- cbind(data_proj, sf::st_coordinates(data_proj))
names(data_proj)[names(data_proj) == "X"] <- "x"  # rename for plotting
names(data_proj)[names(data_proj) == "Y"] <- "y"
# Start building the plot with ggplot
p <- ggplot2::ggplot()
# If we were given a basemap, add it to the plot first (as the background layer)
if (!is.null(basemap)) {
p <- p + ggspatial::layer_spatial(basemap)
}
# Add the heatmap layer — this shows areas with more data points as more intense
p <- p +
ggplot2::stat_density_2d(
data = data_proj,  # the projected spatial data with x and y columns
ggplot2::aes(x = x, y = y, fill = ggplot2::after_stat(level)),  # use density level as the fill
geom = "polygon",   # draw filled contour polygons
contour = TRUE,     # draw contour lines
alpha = 0.5         # make it semi-transparent so you can see the basemap if you added one
) +
ggplot2::scale_fill_viridis_c(option = "cividis") +  # use a colorblind-friendly color scale
ggplot2::labs(
title = if (!is.null(filter_by)) paste("Heatmap:", filter_by) else "Heatmap",  # add a title
x = "Longitude", y = "Latitude"  # label the axes
) +
ggplot2::theme_minimal()  # use a clean minimal background theme
# If there was a basemap, set the plot's coordinate system to match the map
if (!is.null(basemap)) {
p <- p + ggplot2::coord_sf(crs = sf::st_crs(basemap))
}
return(p)  # Return the finished heatmap plot
}
devtools::load_all()
